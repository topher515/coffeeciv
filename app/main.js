// Generated by CoffeeScript 1.3.3
(function() {
  var Civ, UI, Utils, context;

  context = window;

  Civ = context.Civ || (context.Civ = {});

  UI = Civ.UI || (Civ.UI = {});

  Utils = Civ.Utils || (Civ.Utils = {});

  Utils.Cycler = (function() {

    function Cycler(items) {
      this.items = items;
      this.ptr = 0;
      _.bindAll(this);
    }

    Cycler.prototype.next = function() {
      var item;
      item = this.items[this.ptr];
      this.ptr = this.ptr + 1 < this.items.length ? this.ptr + 1 : 0;
      return item;
    };

    return Cycler;

  })();

  Civ.Hex = Backbone.Model.extend({
    defaults: {
      appearance: 'grass',
      movementCosts: {
        land: 1.0,
        air: 1.0,
        sea: Infinity
      },
      defence: 1.0,
      attack: 1.0,
      food: 1.0,
      gold: 1.0,
      prod: 1.0,
      isRoot: false
    },
    initialize: function(opts) {
      this.world = opts.world;
      this.n = null;
      this.ne = null;
      this.se = null;
      this.s = null;
      this.sw = null;
      this.nw = null;
      this.world.registerHex(this);
      return _.bindAll(this);
    },
    registerUnit: function(unit) {
      this.trigger('unit:create', {
        unit: unit,
        hex: this
      });
      return this.trigger('unit:arrive', {
        unit: unit,
        hex: this
      });
    },
    getNames: function() {
      return ['n', 'ne', 'se', 's', 'sw', 'nw'];
    },
    getOppositeName: function(name) {
      return {
        'nw': 'se',
        'ne': 'sw',
        'n': 's',
        'se': 'nw',
        'sw': 'se',
        's': 'n'
      }[name];
    },
    getNeighbors: function() {
      var self;
      self = this;
      return _.map(this.getNames(), function(name) {
        return self[name];
      });
    },
    providesFood: function() {
      return 2;
    },
    providesProd: function() {
      return 1;
    },
    providesGold: function() {
      return 1;
    },
    toJSON: function() {
      var json, self;
      self = this;
      json = Backbone.Model.prototype.toJSON.call(this);
      _.each(this.getNames(), function(name) {
        var _ref;
        return json[name] = (_ref = self[name]) != null ? _ref.id : void 0;
      });
      return json;
    },
    applyCyclic: function(fn, cycle, opts) {
      var curHex, cycler, next, _results;
      curHex = this;
      if (opts != null ? opts.inclusive : void 0) {
        fn(curHex, null, null);
      }
      cycler = new Utils.Cycler(cycle || []);
      next = cycler.next();
      _results = [];
      while (curHex[next]) {
        fn(curHex[next], curHex, next);
        curHex = curHex[next];
        _results.push(next = cycler.next());
      }
      return _results;
    },
    applyRight: function(fn, opts) {
      return this.applyCyclic(fn, ['ne', 'se'], opts);
    },
    applyLeft: function(fn, opts) {
      return this.applyCyclic(fn, ['nw', 'sw'], opts);
    },
    applyUp: function(fn, opts) {
      return this.applyCyclic(fn, ['n'], opts);
    },
    applyDown: function(fn, opts) {
      return this.applyCyclic(fn, ['s'], opts);
    }
  });

  Civ.HexSet = (function() {

    function HexSet() {}

    HexSet.prototype.getHexes = function() {
      return [];
    };

    HexSet.prototype.apply = function(fn) {
      return _.each(this.getHexes(), fn);
    };

    HexSet.prototype.providesGold = function() {
      return _.reduce(this.getHexes(), (function(memo, hex) {
        return memo + hex.providesGold();
      }), 0);
    };

    HexSet.prototype.providesProd = function() {
      return _.reduce(this.getHexes(), (function(memo, hex) {
        return memo + hex.providesProd();
      }), 0);
    };

    HexSet.prototype.providesFood = function() {
      return _.reduce(this.getHexes(), (function(memo, hex) {
        return memo + hex.providesFood();
      }), 0);
    };

    return HexSet;

  })();

  Civ.HexWorld = Backbone.Model.extend({
    defaults: {
      size: 100,
      width: 10,
      height: 10
    },
    initialize: function(options) {
      this.hexes = {};
      this.root = null;
      this.count = 0;
      this.visited = {};
      this.hexGrid = {};
      return _.bindAll(this);
    },
    bubble: function(obj, evtName) {
      return obj.on(evtName, (function(evt) {
        return this.trigger(evtName, evt);
      }), this);
    },
    registerHex: function(hex) {
      hex.id = this.count;
      this.hexes[this.count] = hex;
      this.count += 1;
      return this.bubble(hex, 'unit:create');
    },
    _buildHexesAround: function(hex) {
      var name, newHex, opName, _i, _j, _len, _len1, _ref, _ref1, _results;
      this.visited[hex.id] = true;
      _ref = hex.getNames();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        name = _ref[_i];
        if (!hex[name]) {
          newHex = new Civ.Hex({
            world: this
          });
          hex[name] = newHex;
          opName = newHex.getOppositeName(name);
          newHex[opName] = hex;
          if (this.count >= this.get('size')) {
            return;
          }
        }
      }
      _ref1 = this.current.getNeighbors();
      _results = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        hex = _ref1[_j];
        if (!this.visited[hex.id]) {
          _results.push(this._buildHexesAround(hex));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    },
    buildHexesCircularly: function() {
      var cnt;
      cnt = 0;
      this.current = this.root = new Civ.Hex({
        isRoot: true,
        world: this
      });
      return this._buildHexesAround(this.root);
    },
    _buildHexInDir: function(current, dir) {
      var opDir;
      if (current[dir]) {
        return false;
      }
      current[dir] = new Civ.Hex({
        world: this
      });
      opDir = current.getOppositeName(dir);
      current[dir][opDir] = current;
      return true;
    },
    buildHexesSpirally: function() {
      var built, cameFrom, current, newDir, spiralOrder, _results;
      spiralOrder = {
        'n': ['se', 'ne', 'n'],
        'ne': ['s', 'se', 'ne'],
        'se': ['sw', 's', 'se'],
        'sw': ['n', 'nw', 'sw'],
        'nw': ['ne', 'n', 'nw'],
        's': ['nw', 'ne', 's']
      };
      current = this.root = new Civ.Hex({
        isRoot: true,
        world: this
      });
      cameFrom = 'sw';
      _results = [];
      while (this.count < this.get('size')) {
        _results.push((function() {
          var _i, _len, _ref, _results1;
          _ref = spiralOrder[cameFrom];
          _results1 = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            newDir = _ref[_i];
            built = this._buildHexInDir(current, newDir);
            if (built) {
              cameFrom = newDir;
              current = current[newDir];
              break;
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        }).call(this));
      }
      return _results;
    },
    buildHexesInGrid: function() {
      var center, coord, hex, hexGrid, x, y, _i, _j, _k, _l, _m, _ref, _ref1, _ref2, _ref3, _ref4, _results;
      hexGrid = this.hexGrid;
      center = "" + (this.get('width') / 2) + "," + (this.get('height') / 2);
      for (x = _i = 0, _ref = this.get('width'); 0 <= _ref ? _i <= _ref : _i >= _ref; x = 0 <= _ref ? ++_i : --_i) {
        for (y = _j = 0, _ref1 = this.get('height'); 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
          coord = "" + x + "," + y;
          hexGrid[coord] = new Civ.Hex({
            world: this
          });
        }
      }
      this.root = hexGrid["0,0"];
      for (x = _k = 0, _ref2 = this.get('width'); _k <= _ref2; x = _k += 2) {
        for (y = _l = 0, _ref3 = this.get('height'); 0 <= _ref3 ? _l <= _ref3 : _l >= _ref3; y = 0 <= _ref3 ? ++_l : --_l) {
          hex = hexGrid["" + x + "," + y];
          hex.n = hexGrid["" + x + "," + (y - 1)];
          hex.ne = hexGrid["" + (x + 1) + "," + y];
          hex.se = hexGrid["" + (x + 1) + "," + (y + 1)];
          hex.s = hexGrid["" + x + "," + (y + 1)];
          hex.sw = hexGrid["" + (x - 1) + "," + (y + 1)];
          hex.nw = hexGrid["" + (x - 1) + "," + y];
        }
      }
      _results = [];
      for (x = _m = 1, _ref4 = this.get('width') - 1; _m <= _ref4; x = _m += 2) {
        _results.push((function() {
          var _n, _ref5, _results1;
          _results1 = [];
          for (y = _n = 0, _ref5 = this.get('height'); 0 <= _ref5 ? _n <= _ref5 : _n >= _ref5; y = 0 <= _ref5 ? ++_n : --_n) {
            hex = hexGrid["" + x + "," + y];
            hex.n = hexGrid["" + x + "," + (y - 1)];
            hex.ne = hexGrid["" + (x + 1) + "," + (y - 1)];
            hex.se = hexGrid["" + (x + 1) + "," + y];
            hex.s = hexGrid["" + x + "," + (y + 1)];
            hex.sw = hexGrid["" + (x - 1) + "," + y];
            _results1.push(hex.nw = hexGrid["" + (x - 1) + "," + (y - 1)]);
          }
          return _results1;
        }).call(this));
      }
      return _results;
    }
  });

  Civ.SingleUnit = Backbone.Model.extend({
    initialize: function(options) {
      this.hex = options.hex;
      this.civ = options.civ;
      this.hex.registerUnit(this);
      return this.civ.registerUnit(this);
    },
    validMove: function(newHex) {
      return Boolean(newHex);
    },
    moveTo: function(newHex) {
      var oldHex;
      if (!this.validMove(newHex)) {
        throw "Invalid Movement Direction";
      }
      oldHex = this.hex;
      this.hex = newHex;
      this.trigger('unit:move', {
        to: newHex,
        from: oldHex,
        unit: this
      });
      oldHex.trigger('unit:leave', {
        unit: this,
        hex: oldHex
      });
      return newHex.trigger('unit:arrive', {
        unit: this,
        hex: newHex
      });
    },
    move: function(dir) {
      return this.moveTo(this.hex[dir]);
    }
  });

  Civ.City = (function() {

    function City(name, opts) {
      this.population = opts.popultion || 10;
      this.health = 1.0;
      this.supplyOfFood = 0;
      this.name = name;
      this.hexset = new Civ.HexSet;
    }

    City.prototype.calcGold = function() {
      return this.hexset.providesGold();
    };

    City.prototype.calcProd = function() {
      return this.hexset.providesProd();
    };

    City.prototype.calcFood = function() {
      return this.hexset.providesFood();
    };

    City.prototype.calcScience = function() {};

    City.prototype.tick = function() {
      return this.supplyOfFood += this.calculateFood();
    };

    return City;

  })();

  Civ.Government = Backbone.Model.extend({
    initialize: function(opts) {
      return this.civ = opts.civ;
    }
  });

  Civ.Tribal = Civ.Government.extend({
    name: "Tribal"
  });

  Civ.Monarchy = Civ.Government.extend({
    name: "Monarchy"
  });

  Civ.Civilization = Backbone.Model.extend({
    defaults: {
      name: "Unnamed"
    },
    initialize: function(attrs) {
      this.player = attrs.player;
      this.government = new Civ.Tribal({
        civ: this
      });
      this.scienceGraph = new Civ.ScienceGraph;
      this.currentResearch = null;
      this.cities = [];
      return this.units = [];
    },
    registerUnit: function(unit) {
      this.player.registerUnit(unit);
      return this.units.push(unit);
    },
    getCities: function() {
      return this.cities;
    },
    getUnits: function() {
      return this.units;
    },
    calcScience: function() {
      return _.reduce(this.getCities(), (function(memo, city) {
        return memo + city.calculateScience();
      }), 0);
    },
    tickScience: function() {
      var sci;
      sci = this.calcScience();
      return this.scienceGraph.doProgress(sci);
    },
    tick: function() {
      return tickScience();
    }
  });

  Civ.Player = Backbone.Model.extend({
    initialize: function(opts) {}
  });

  Civ.HumanPlayer = Civ.Player.extend({
    registerUnit: function(unit) {
      return this.trigger('selectable:registered', unit);
    }
  });

}).call(this);
