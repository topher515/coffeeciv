// Generated by CoffeeScript 1.3.3
(function() {
  var Civ, UI, Utils, context;

  context = window;

  Civ = context.Civ || (context.Civ = {});

  UI = Civ.UI || (Civ.UI = {});

  Utils = Civ.Utils || (Civ.Utils = {});

  Utils.Cycler = (function() {

    function Cycler(items) {
      this.items = items;
      this.ptr = 0;
      _.bindAll(this);
    }

    Cycler.prototype.next = function() {
      var item;
      item = this.items[this.ptr];
      this.ptr = this.ptr + 1 < this.items.length ? this.ptr + 1 : 0;
      return item;
    };

    return Cycler;

  })();

  Civ.Hex = Backbone.Model.extend({
    defaults: {
      appearance: 'grass',
      movementCosts: {
        land: 1.0,
        air: 1.0,
        sea: Infinity
      },
      defence: 1.0,
      attack: 1.0,
      food: 1.0,
      gold: 1.0,
      prod: 1.0,
      isRoot: false
    },
    initialize: function(opts) {
      this.world = opts.world;
      this.n = null;
      this.ne = null;
      this.se = null;
      this.s = null;
      this.sw = null;
      this.nw = null;
      this.world.registerHex(this);
      return _.bindAll(this);
    },
    registerUnit: function(unit) {
      this.trigger('unit:create', {
        unit: unit,
        hex: this
      });
      return this.trigger('unit:arrive', {
        unit: unit,
        hex: this
      });
    },
    getNames: function() {
      return ['n', 'ne', 'se', 's', 'sw', 'nw'];
    },
    getOppositeName: function(name) {
      return {
        'nw': 'se',
        'ne': 'sw',
        'n': 's',
        'se': 'nw',
        'sw': 'se',
        's': 'n'
      }[name];
    },
    getNeighbors: function() {
      var self;
      self = this;
      return _.map(this.getNames(), function(name) {
        return self[name];
      });
    },
    providesFood: function() {
      return 2;
    },
    providesProd: function() {
      return 1;
    },
    providesGold: function() {
      return 1;
    },
    toJSON: function() {
      var json, self;
      self = this;
      json = Backbone.Model.prototype.toJSON.call(this);
      _.each(this.getNames(), function(name) {
        var _ref;
        return json[name] = (_ref = self[name]) != null ? _ref.id : void 0;
      });
      return json;
    },
    applyCyclic: function(fn, cycle, opts) {
      var curHex, cycler, next, _results;
      curHex = this;
      if (opts != null ? opts.inclusive : void 0) {
        fn(curHex, null, null);
      }
      cycler = new Utils.Cycler(cycle || []);
      next = cycler.next();
      _results = [];
      while (curHex[next]) {
        fn(curHex[next], curHex, next);
        curHex = curHex[next];
        _results.push(next = cycler.next());
      }
      return _results;
    },
    applyRight: function(fn, opts) {
      return this.applyCyclic(fn, ['nw', 'sw'], opts);
    },
    applyLeft: function(fn, opts) {
      return this.applyCyclic(fn, ['ne', 'se'], opts);
    },
    applyUp: function(fn, opts) {
      return this.applyCyclic(fn, ['n'], opts);
    },
    applyDown: function(fn, opts) {
      return this.applyCyclic(fn, ['s'], opts);
    }
  });

  Civ.HexSet = (function() {

    function HexSet() {}

    HexSet.prototype.getHexes = function() {
      return [];
    };

    HexSet.prototype.apply = function(fn) {
      return _.each(this.getHexes(), fn);
    };

    HexSet.prototype.providesGold = function() {
      return _.reduce(this.getHexes(), (function(memo, hex) {
        return memo + hex.providesGold();
      }), 0);
    };

    HexSet.prototype.providesProd = function() {
      return _.reduce(this.getHexes(), (function(memo, hex) {
        return memo + hex.providesProd();
      }), 0);
    };

    HexSet.prototype.providesFood = function() {
      return _.reduce(this.getHexes(), (function(memo, hex) {
        return memo + hex.providesFood();
      }), 0);
    };

    return HexSet;

  })();

  Civ.HexWorld = Backbone.Model.extend({
    defaults: {
      size: 100
    },
    initialize: function(options) {
      this.hexes = {};
      this.root = null;
      this.count = 0;
      this.visited = {};
      return _.bindAll(this);
    },
    bubble: function(obj, evtName) {
      return obj.on(evtName, (function(evt) {
        return this.trigger(evtName, evt);
      }), this);
    },
    registerHex: function(hex) {
      hex.id = this.count;
      this.hexes[this.count] = hex;
      this.count += 1;
      return this.bubble(hex, 'unit:create');
    },
    _buildHexesAround: function(hex) {
      var name, newHex, opName, _i, _j, _len, _len1, _ref, _ref1, _results;
      this.visited[hex.id] = true;
      _ref = hex.getNames();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        name = _ref[_i];
        if (!hex[name]) {
          newHex = new Civ.Hex({
            world: this
          });
          hex[name] = newHex;
          opName = newHex.getOppositeName(name);
          newHex[opName] = hex;
          if (this.count >= this.get('size')) {
            return;
          }
        }
      }
      _ref1 = this.current.getNeighbors();
      _results = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        hex = _ref1[_j];
        if (!this.visited[hex.id]) {
          _results.push(this._buildHexesAround(hex));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    },
    buildHexesCircularly: function() {
      var cnt;
      cnt = 0;
      this.current = this.root = new Civ.Hex({
        isRoot: true,
        world: this
      });
      return this._buildHexesAround(this.root);
    }
  });

  Civ.SingleUnit = Backbone.Model.extend({
    initialize: function(options) {
      this.hex = options.hex;
      this.civ = options.civ;
      this.hex.registerUnit(this);
      return this.civ.registerUnit(this);
    },
    validMove: function(newHex) {
      return Boolean(newHex);
    },
    moveTo: function(newHex) {
      var oldHex;
      if (!this.validMove(newHex)) {
        throw "Invalid Movement Direction";
      }
      oldHex = this.hex;
      this.hex = newHex;
      this.trigger('unit:move', {
        to: newHex,
        from: oldHex,
        unit: this
      });
      oldHex.trigger('unit:leave', {
        unit: this,
        hex: oldHex
      });
      return newHex.trigger('unit:arrive', {
        unit: this,
        hex: newHex
      });
    },
    move: function(dir) {
      return this.moveTo(this.hex[dir]);
    }
  });

  Civ.City = (function() {

    function City(name, opts) {
      this.population = opts.popultion || 10;
      this.health = 1.0;
      this.supplyOfFood = 0;
      this.name = name;
      this.hexset = new Civ.HexSet;
    }

    City.prototype.calcGold = function() {
      return this.hexset.providesGold();
    };

    City.prototype.calcProd = function() {
      return this.hexset.providesProd();
    };

    City.prototype.calcFood = function() {
      return this.hexset.providesFood();
    };

    City.prototype.calcScience = function() {};

    City.prototype.tick = function() {
      return this.supplyOfFood += this.calculateFood();
    };

    return City;

  })();

  Civ.Government = Backbone.Model.extend({
    initialize: function(opts) {
      return this.civ = opts.civ;
    }
  });

  Civ.Tribal = Civ.Government.extend({
    name: "Tribal"
  });

  Civ.Monarchy = Civ.Government.extend({
    name: "Monarchy"
  });

  Civ.Civilization = Backbone.Model.extend({
    defaults: {
      name: "Unnamed"
    },
    initialize: function(attrs) {
      this.player = attrs.player;
      this.government = new Civ.Tribal({
        civ: this
      });
      this.scienceGraph = new Civ.ScienceGraph;
      this.currentResearch = null;
      this.cities = [];
      return this.units = [];
    },
    registerUnit: function(unit) {
      this.player.registerUnit(unit);
      return this.units.push(unit);
    },
    getCities: function() {
      return this.cities;
    },
    getUnits: function() {
      return this.units;
    },
    calcScience: function() {
      return _.reduce(this.getCities(), (function(memo, city) {
        return memo + city.calculateScience();
      }), 0);
    },
    tickScience: function() {
      var sci;
      sci = this.calcScience();
      return this.scienceGraph.doProgress(sci);
    },
    tick: function() {
      return tickScience();
    }
  });

  Civ.Player = Backbone.Model.extend({
    initialize: function(opts) {}
  });

  Civ.HumanPlayer = Civ.Player.extend({
    registerUnit: function(unit) {
      return this.trigger('selectable:registered', unit);
    }
  });

}).call(this);
